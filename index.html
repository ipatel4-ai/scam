<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Nora, will you be my Valentine?</title>

  <!-- Cute fonts -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@500;700;800&family=Pacifico&display=swap" rel="stylesheet">

  <style>
    :root{
      --pink:#ffe4ef;
      --hot:#ff2f7a;
      --shadow: 0 14px 40px rgba(0,0,0,0.12);
      --card:#ffffffee;
    }

    body{
      margin:0;
      height:100vh;
      display:grid;
      place-items:center;
      font-family:Poppins, system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      overflow:hidden;
      background-color: var(--pink);
      position:relative;
    }

    /* Heart-outline pattern background */
    body::before{
      content:"";
      position:fixed;
      inset:0;
      pointer-events:none;
      opacity:0.22;
      background-repeat:repeat;
      background-size: 120px 120px;
      background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='120' height='120' viewBox='0 0 120 120'%3E%3Cg fill='none' stroke='%23ff2f7a' stroke-width='3'%3E%3Cpath d='M60 78 C45 66 30 56 30 42 C30 32 38 25 48 25 C55 25 59 29 60 32 C61 29 65 25 72 25 C82 25 90 32 90 42 C90 56 75 66 60 78 Z'/%3E%3C/g%3E%3C/svg%3E");
    }

    /* Floating hearts layer */
    .hearts-layer{
      position: fixed;
      inset: 0;
      pointer-events: none;
      z-index: 1;
      overflow: hidden;
    }
    .heart-float{
      position: absolute;
      bottom: -50px;
      font-size: 18px;
      opacity: 0.30;
      filter: drop-shadow(0 10px 12px rgba(0,0,0,0.10));
      animation: floatUp linear forwards;
      will-change: transform, opacity;
    }
    @keyframes floatUp{
      0%   { transform: translateY(0) translateX(0) scale(1); opacity: 0.0; }
      12%  { opacity: 0.30; }
      100% { transform: translateY(-125vh) translateX(var(--drift)) scale(var(--scale)); opacity: 0.0; }
    }

    .card{
      background: var(--card);
      border: 1px solid rgba(0,0,0,0.08);
      border-radius: 22px;
      padding: 30px 26px;
      box-shadow: var(--shadow);
      text-align:center;
      width:min(600px, 92vw);
      position:relative;
      z-index:2;
      backdrop-filter: blur(6px);
    }

    h1{
      margin:0 0 10px;
      font-size: clamp(28px, 4vw, 44px);
      color:#222;
      font-family: Pacifico, Poppins, system-ui;
      font-weight: 400;
    }

    p{
      margin: 0 0 18px;
      color:#444;
      font-weight: 800;
    }

    .buttons{
      display:flex;
      justify-content:center;
      align-items:center;
      gap:14px;
      flex-wrap:wrap;
      position:relative;
      z-index:2;
      margin-top: 6px;
    }

    /* Buttons + hover bounce/glow */
    button{
      font-size:18px;
      padding:12px 22px;
      border-radius:14px;
      border:none;
      cursor:pointer;
      user-select:none;
      -webkit-tap-highlight-color:transparent;
      font-weight: 800;
      transition: transform 160ms ease, box-shadow 180ms ease, filter 180ms ease;
    }
    button:hover{
      transform: translateY(-2px) scale(1.03);
      box-shadow: 0 14px 28px rgba(0,0,0,0.12);
      filter: brightness(1.02);
    }
    button:active{ transform: scale(0.98); }

    #yesBtn{
      background: var(--hot);
      color:white;
      box-shadow: 0 10px 22px rgba(255,47,122,0.25);
    }
    #yesBtn:hover{
      box-shadow: 0 16px 34px rgba(255,47,122,0.28);
    }

    /* No bundle */
    #noWrap{
      display:inline-flex;
      align-items:center;
      gap:10px;
      position: relative;
    }

    /* Devil hidden initially; appears only after hovering No */
    #devil{
      font-size:24px;
      line-height:1;
      filter: drop-shadow(0 6px 10px rgba(0,0,0,0.15));
      transform: translateY(1px);
      display: none;
    }
    #devil.show{
      display: inline-block;
    }

    #noBtn{
      background:#ededed;
      color:#222;
      box-shadow: 0 8px 18px rgba(0,0,0,0.08);
    }

    /* Free-floating state for No+devil */
    #noWrap.free{
      position:fixed;
      left: 50%;
      top: 50%;
      transform: translate(-50%, -50%);
      z-index:5;
      will-change:left, top;
    }
    #noWrap.smooth{
      transition: left 420ms cubic-bezier(.2,.9,.2,1),
                  top  420ms cubic-bezier(.2,.9,.2,1);
    }
    #noWrap.track{
      transition: none;
    }

    .result{
      margin-top:16px;
      font-size:18px;
      font-weight:900;
      color: var(--hot);
      min-height:24px;
    }

    /* Sound toggle UI */
    .topbar{
      position: fixed;
      top: 14px;
      right: 14px;
      z-index: 20;
      display: flex;
      align-items: center;
      gap: 10px;
      background: rgba(255,255,255,0.70);
      border: 1px solid rgba(0,0,0,0.08);
      border-radius: 14px;
      padding: 8px 10px;
      box-shadow: 0 10px 24px rgba(0,0,0,0.10);
      backdrop-filter: blur(6px);
    }
    .toggle{
      display:flex;
      align-items:center;
      gap:8px;
      font-weight: 900;
      color:#333;
      font-size: 14px;
      user-select:none;
    }
    .toggle input{ transform: translateY(1px); }

    /* Canvases */
    #confettiCanvas, #fireworksCanvas{
      position: fixed;
      inset: 0;
      pointer-events: none;
      display: none;
    }
    #confettiCanvas{ z-index: 10; }
    #fireworksCanvas{ z-index: 9; }

    /* Yes modal */
    .modal{
      position: fixed;
      inset: 0;
      display: none;
      place-items: center;
      background: rgba(0,0,0,0.18);
      z-index: 30;
      padding: 18px;
    }
    .modal .box{
      width: min(600px, 92vw);
      background: rgba(255,255,255,0.96);
      border: 1px solid rgba(0,0,0,0.08);
      border-radius: 22px;
      box-shadow: var(--shadow);
      padding: 26px 22px;
      text-align: center;
    }
    .modal h2{
      margin: 0 0 10px;
      font-size: clamp(22px, 3.3vw, 34px);
      color:#222;
      font-weight: 900;
    }
    .modal .big{
      margin: 6px 0 14px;
      font-size: clamp(20px, 3.2vw, 30px);
      font-weight: 900;
      color: var(--hot);
    }
    .modal button{
      background: #ffffff;
      border: 1px solid rgba(0,0,0,0.10);
      padding: 10px 16px;
      border-radius: 12px;
      cursor: pointer;
      font-weight: 900;
    }
  </style>
</head>

<body>
  <div class="topbar">
    <label class="toggle" title="Enable/disable sounds">
      <input type="checkbox" id="soundToggle" checked />
      ðŸ”Š Sound
    </label>
  </div>

  <div class="hearts-layer" id="heartsLayer"></div>

  <div class="card" id="card">
    <h1>Nora, will you be my Valentine?</h1>
    <p>(Choose wisely ðŸ˜‡)</p>

    <div class="buttons">
      <button id="yesBtn">Yes ðŸ’–</button>

      <span id="noWrap">
        <span id="devil" title="Nice try ðŸ˜ˆ">ðŸ˜ˆ</span>
        <button id="noBtn">No ðŸ™ƒ</button>
      </span>
    </div>

    <div class="result" id="result"></div>
  </div>

  <canvas id="fireworksCanvas"></canvas>
  <canvas id="confettiCanvas"></canvas>

  <div class="modal" id="yesModal" role="dialog" aria-modal="true" aria-label="Valentine message">
    <div class="box">
      <h2>YAY!!! ðŸ’˜ðŸ’˜</h2>
      <div class="big">Nora + Ish + Pastorâ€™s dinner date ðŸ˜‰</div>
      <button id="closeModalBtn">Aww okay ðŸ˜„</button>
    </div>
  </div>

  <script>
    // ---------------------------
    // Sound
    // ---------------------------
    const soundToggle = document.getElementById("soundToggle");

    function beep(freq=660, duration=0.06, type="sine", gainVal=0.06){
      if (!soundToggle.checked) return;
      const AudioCtx = window.AudioContext || window.webkitAudioContext;
      if (!AudioCtx) return;
      const ctx = beep._ctx || (beep._ctx = new AudioCtx());
      const o = ctx.createOscillator();
      const g = ctx.createGain();
      o.type = type;
      o.frequency.value = freq;
      g.gain.value = gainVal;
      o.connect(g); g.connect(ctx.destination);
      const t = ctx.currentTime;
      o.start(t);
      g.gain.setValueAtTime(gainVal, t);
      g.gain.exponentialRampToValueAtTime(0.0001, t + duration);
      o.stop(t + duration);
    }

    function cuteYesSound(){
      beep(784, 0.06, "sine", 0.07);
      setTimeout(() => beep(988, 0.06, "sine", 0.07), 70);
      setTimeout(() => beep(1175, 0.08, "sine", 0.07), 140);
    }

    // ---------------------------
    // Floating hearts (pink/red palette)
    // ---------------------------
    const heartsLayer = document.getElementById("heartsLayer");
    const heartChars = ["â™¡","â™¥","â™¡","â™¥","â™¡"];
    const heartColors = ["#ff2f7a","#ff4d88","#ff6fa3","#ff1f4f","#ff8fb9","#ff3b6e","#ff5c9a"];

    function spawnHeart(){
      const heart = document.createElement("div");
      heart.className = "heart-float";
      heart.textContent = heartChars[Math.floor(Math.random() * heartChars.length)];

      const x = Math.random() * 100;
      const duration = 6 + Math.random() * 6;
      const drift = (Math.random() * 120 - 60) + "px";
      const scale = (0.8 + Math.random() * 1.2).toFixed(2);

      heart.style.left = x + "vw";
      heart.style.animationDuration = duration + "s";
      heart.style.setProperty("--drift", drift);
      heart.style.setProperty("--scale", scale);
      heart.style.color = heartColors[Math.floor(Math.random() * heartColors.length)];
      heart.style.opacity = (0.22 + Math.random()*0.18).toFixed(2);

      heartsLayer.appendChild(heart);
      setTimeout(() => heart.remove(), duration * 1000);
    }
    for (let i=0; i<10; i++) setTimeout(spawnHeart, i * 250);
    setInterval(spawnHeart, 450);

    // ---------------------------
    // NO + devil behavior
    // Devil appears only after hovering No (and stays with No).
    // "No ðŸ™ƒ" becomes "Nice try ðŸ˜ˆ" after first hover.
    // The devil "takes away" the No option by appearing and fleeing with it.
    // ---------------------------
    const pxPerInch = 96;
    const radiusPx = 2 * pxPerInch;
    const margin = 10;

    const noWrap = document.getElementById("noWrap");
    const noBtn  = document.getElementById("noBtn");
    const devil  = document.getElementById("devil");
    const yesBtn = document.getElementById("yesBtn");
    const result = document.getElementById("result");

    let isFree = false;
    let tracking = false;
    let hasHoveredNo = false;

    let mouse = { x: window.innerWidth/2, y: window.innerHeight/2 };
    let prevMouse = { x: mouse.x, y: mouse.y, t: performance.now() };
    let currentPos = null;

    function clamp(v, min, max){ return Math.max(min, Math.min(max, v)); }

    function clampToViewport(left, top, el){
      const r = el.getBoundingClientRect();
      const maxL = window.innerWidth  - r.width  - margin;
      const maxT = window.innerHeight - r.height - margin;
      return { left: clamp(left, margin, maxL), top: clamp(top, margin, maxT) };
    }

    function detachIfNeeded(){
      if (isFree) return;
      const rect = noWrap.getBoundingClientRect();
      noWrap.classList.add("free", "smooth");
      noWrap.classList.remove("track");

      const left = rect.left + rect.width/2;
      const top  = rect.top  + rect.height/2;

      currentPos = { left, top };
      noWrap.style.left = left + "px";
      noWrap.style.top  = top  + "px";
      noWrap.style.transform = "translate(-50%, -50%)";
      isFree = true;
    }

    function moveRandomAway(){
      detachIfNeeded();

      const left = margin + Math.random() * (window.innerWidth  - 2*margin);
      const top  = margin + Math.random() * (window.innerHeight - 2*margin);
      const clamped = clampToViewport(left, top, noWrap);
      currentPos = { left: clamped.left, top: clamped.top };

      noWrap.classList.add("smooth");
      noWrap.classList.remove("track");
      noWrap.style.left = currentPos.left + "px";
      noWrap.style.top  = currentPos.top  + "px";

      beep(220, 0.05, "square", 0.03);
    }

    function handleMouseMove(e){
      mouse.x = e.clientX;
      mouse.y = e.clientY;

      if (tracking) return;

      const r = noWrap.getBoundingClientRect();
      const cx = r.left + r.width/2;
      const cy = r.top  + r.height/2;

      const dist = Math.hypot(mouse.x - cx, mouse.y - cy);
      const triggerDistance = 120;

      if (dist < triggerDistance) moveRandomAway();
    }
    window.addEventListener("mousemove", handleMouseMove);

    // Hovering NO reveals devil + changes button text, then devil "takes it away" (detach + flee)
    noBtn.addEventListener("mouseenter", () => {
      if (!hasHoveredNo) {
        hasHoveredNo = true;
        devil.classList.add("show");      // devil appears ONLY now
        noBtn.textContent = "Nice try ðŸ˜ˆ"; // change label after hover
      } else {
        devil.classList.add("show");      // ensure visible on subsequent hovers
      }

      // Devil "takes it away": detach and start fleeing immediately
      detachIfNeeded();
      moveRandomAway();

      // Sticky chase only while she's on it (optional)
      tracking = true;
      noWrap.classList.remove("smooth");
      noWrap.classList.add("track");
      beep(520, 0.05, "sine", 0.03);
    });

    noBtn.addEventListener("mouseleave", () => {
      tracking = false;
      noWrap.classList.add("smooth");
      noWrap.classList.remove("track");
      // devil stays visible once introduced (keeps running away with it)
    });

    noBtn.addEventListener("touchstart", (e) => {
      e.preventDefault();
      if (!hasHoveredNo) {
        hasHoveredNo = true;
        devil.classList.add("show");
        noBtn.textContent = "Nice try ðŸ˜ˆ";
      } else {
        devil.classList.add("show");
      }

      detachIfNeeded();
      moveRandomAway();

      tracking = true;
      noWrap.classList.remove("smooth");
      noWrap.classList.add("track");
      beep(520, 0.06, "sine", 0.03);
    }, { passive:false });

    noBtn.addEventListener("click", (e) => {
      e.preventDefault();
      moveRandomAway();
    });

    // Sticky chase loop
    function animate(){
      const now = performance.now();
      const dt = Math.max(1, now - prevMouse.t);

      const vx = (mouse.x - prevMouse.x) / dt;
      const vy = (mouse.y - prevMouse.y) / dt;
      const speed = Math.hypot(vx, vy);

      prevMouse = { x: mouse.x, y: mouse.y, t: now };

      if (tracking && isFree && currentPos){
        const angle = Math.atan2(vy || 0.001, vx || 0.001) + Math.PI;
        const targetLeft = mouse.x + Math.cos(angle) * radiusPx * 0.65;
        const targetTop  = mouse.y + Math.sin(angle) * radiusPx * 0.65;

        const clamped = clampToViewport(targetLeft, targetTop, noWrap);

        const follow = clamp(0.08 + speed * 0.9, 0.08, 0.45);

        currentPos.left += (clamped.left - currentPos.left) * follow;
        currentPos.top  += (clamped.top  - currentPos.top)  * follow;

        const again = clampToViewport(currentPos.left, currentPos.top, noWrap);
        currentPos.left = again.left;
        currentPos.top  = again.top;

        noWrap.style.left = currentPos.left + "px";
        noWrap.style.top  = currentPos.top  + "px";
      }

      requestAnimationFrame(animate);
    }
    requestAnimationFrame(animate);

    window.addEventListener("resize", () => {
      if (!isFree || !currentPos) return;
      const clamped = clampToViewport(currentPos.left, currentPos.top, noWrap);
      currentPos = clamped;
      noWrap.style.left = currentPos.left + "px";
      noWrap.style.top  = currentPos.top  + "px";
    });

    // ---------------------------
    // Heart fireworks + multicolor confetti on YES
    // ---------------------------
    const fireworksCanvas = document.getElementById("fireworksCanvas");
    const fctx = fireworksCanvas.getContext("2d");

    const confettiCanvas = document.getElementById("confettiCanvas");
    const cctx = confettiCanvas.getContext("2d");

    function resizeCanvases(){
      const dpr = devicePixelRatio || 1;

      fireworksCanvas.width  = window.innerWidth * dpr;
      fireworksCanvas.height = window.innerHeight * dpr;
      fctx.setTransform(dpr,0,0,dpr,0,0);

      confettiCanvas.width  = window.innerWidth * dpr;
      confettiCanvas.height = window.innerHeight * dpr;
      cctx.setTransform(dpr,0,0,dpr,0,0);
    }
    window.addEventListener("resize", resizeCanvases);
    resizeCanvases();

    let bursts = [];
    let fireworksRunning = false;

    function rand(min,max){ return min + Math.random()*(max-min); }

    function addBurst(x, y){
      const n = 44 + Math.floor(Math.random()*18);
      const parts = [];
      for (let i=0;i<n;i++){
        const a = (i/n) * Math.PI * 2;
        const sp = rand(2.0, 5.6);
        parts.push({
          x, y,
          vx: Math.cos(a)*sp*rand(0.7,1.2),
          vy: Math.sin(a)*sp*rand(0.7,1.2),
          life: rand(38, 70),
          color: heartColors[Math.floor(Math.random()*heartColors.length)],
          size: rand(6, 12),
          vr: rand(-0.12, 0.12)
        });
      }
      bursts.push(parts);
    }

    function drawHeartOutline(ctx, x, y, s, color){
      ctx.save();
      ctx.translate(x,y);
      ctx.beginPath();
      const t = s * 0.3;
      ctx.moveTo(0, t);
      ctx.bezierCurveTo(0, 0, -s/2, 0, -s/2, t);
      ctx.bezierCurveTo(-s/2, (s+t)/2, 0, (s+t)/2, 0, s);
      ctx.bezierCurveTo(0, (s+t)/2, s/2, (s+t)/2, s/2, t);
      ctx.bezierCurveTo(s/2, 0, 0, 0, 0, t);
      ctx.closePath();
      ctx.strokeStyle = color;
      ctx.lineWidth = 2;
      ctx.globalAlpha = 0.85;
      ctx.stroke();
      ctx.restore();
    }

    function fireworksFrame(){
      if (!fireworksRunning) return;

      fctx.clearRect(0,0,window.innerWidth, window.innerHeight);
      bursts = bursts.filter(parts => parts.length > 0);

      for (const parts of bursts){
        for (let i=parts.length-1;i>=0;i--){
          const p = parts[i];
          p.x += p.vx;
          p.y += p.vy;
          p.vx *= 0.985;
          p.vy = p.vy*0.985 + 0.04;
          p.life -= 1;

          drawHeartOutline(fctx, p.x, p.y, p.size, p.color);

          if (p.life <= 0 || p.y > window.innerHeight + 30) parts.splice(i,1);
        }
      }

      if (bursts.length > 0) requestAnimationFrame(fireworksFrame);
      else { fireworksRunning = false; fireworksCanvas.style.display = "none"; }
    }

    function startHeartFireworks(){
      fireworksCanvas.style.display = "block";
      fireworksRunning = true;

      addBurst(window.innerWidth*0.35, window.innerHeight*0.35);
      addBurst(window.innerWidth*0.65, window.innerHeight*0.32);
      setTimeout(()=>addBurst(window.innerWidth*0.50, window.innerHeight*0.28), 260);
      setTimeout(()=>addBurst(window.innerWidth*0.50, window.innerHeight*0.45), 520);

      requestAnimationFrame(fireworksFrame);

      if (soundToggle.checked){
        beep(520,0.05,"sine",0.04);
        setTimeout(()=>beep(620,0.05,"sine",0.04),120);
        setTimeout(()=>beep(740,0.06,"sine",0.04),240);
      }
    }

    // Multicolor confetti
    let confettiPieces = [];
    let confettiRunning = false;
    const confettiColors = ["#ff2f7a","#ffd166","#06d6a0","#118ab2","#9b5de5","#ff595e","#8ac926","#1982c4","#ffca3a"];

    function makeConfetti(count=240){
      confettiPieces = Array.from({length: count}).map(() => {
        const size = 5 + Math.random()*9;
        return {
          x: Math.random()*window.innerWidth,
          y: -20 - Math.random()*window.innerHeight*0.25,
          vx: (Math.random()-0.5)*4.2,
          vy: 2.8 + Math.random()*5.2,
          rot: Math.random()*Math.PI*2,
          vr: (Math.random()-0.5)*0.25,
          size,
          color: confettiColors[Math.floor(Math.random()*confettiColors.length)],
          wobble: Math.random()*1000
        };
      });
    }

    function confettiFrame(){
      if (!confettiRunning) return;
      cctx.clearRect(0,0,window.innerWidth, window.innerHeight);

      for (const p of confettiPieces){
        p.x += p.vx + Math.sin((performance.now() + p.wobble)/220)*0.7;
        p.y += p.vy;
        p.rot += p.vr;
        p.vx *= 0.992;
        p.vy *= 0.995;
        p.vy += 0.03;

        cctx.save();
        cctx.translate(p.x, p.y);
        cctx.rotate(p.rot);
        cctx.globalAlpha = 0.92;
        cctx.fillStyle = p.color;
        cctx.fillRect(-p.size/2, -p.size/2, p.size, p.size);
        cctx.restore();
      }

      confettiPieces = confettiPieces.filter(p => p.y < window.innerHeight + 40);

      if (confettiPieces.length > 0) requestAnimationFrame(confettiFrame);
      else { confettiRunning = false; confettiCanvas.style.display = "none"; }
    }

    function startConfetti(){
      confettiCanvas.style.display = "block";
      makeConfetti(260);
      confettiRunning = true;
      requestAnimationFrame(confettiFrame);
      setTimeout(()=>{ confettiPieces = []; }, 3200);
    }

    // ---------------------------
    // YES click: hide the runaway No+devil only after YES
    // ---------------------------
    const yesModal = document.getElementById("yesModal");
    const closeModalBtn = document.getElementById("closeModalBtn");

    yesBtn.addEventListener("click", () => {
      result.textContent = "YAY!!! ðŸ’˜ðŸ’˜";
      yesBtn.disabled = true;

      // Now remove No+devil
      noWrap.style.display = "none";

      cuteYesSound();
      startHeartFireworks();
      startConfetti();

      yesModal.style.display = "grid";
    });

    closeModalBtn.addEventListener("click", () => {
      yesModal.style.display = "none";
    });

    yesModal.addEventListener("click", (e) => {
      if (e.target === yesModal) yesModal.style.display = "none";
    });
  </script>
</body>
</html>

